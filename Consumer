public class Main {
    public static void main(String[] args) {
        if (args.length != 5) {
            System.out.println("Use: java Main <num_producers> <max_items_per_producer> <producing_time> <num_consumers> <consuming_time>");
            return;
        }

        int numProducers = Integer.parseInt(args[0]);
        int maxItemsPerProducer = Integer.parseInt(args[1]);
        int producingTime = Integer.parseInt(args[2]);
        int numConsumers = Integer.parseInt(args[3]);
        int consumingTime = Integer.parseInt(args[4]);

        Buffer buffer = new Buffer();

        long startTime = System.currentTimeMillis(); // <ADICIONADO>

        for (int i = 1; i <= numProducers; i++) {
            Thread t = new Thread(new Producer(i, buffer, maxItemsPerProducer, producingTime)); // <EDITADO>
            t.start(); // <ADICIONADO>
        }

        for (int i = 1; i <= numConsumers; i++) {
            boolean consumeEven = i % 2 == 0; // <ADICIONADO>
            Thread t = new Thread(new Consumer(i, buffer, consumingTime, consumeEven)); // <EDITADO>
            t.start(); // <ADICIONADO>
        }

        // Apenas exemplo de métrica simples (não garante fim de execução)
        new Thread(() -> {
            try {
                Thread.sleep(10000); // Espera 10s para mostrar tempo
                long elapsed = System.currentTimeMillis() - startTime;
                System.out.println("Elapsed time (ms): " + elapsed); // <ADICIONADO>
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}

class Producer implements Runnable { // <EDITADO>
    private final Buffer buffer;
    private final int maxItems;
    private final int sleepTime;
    private final int id;

    public Producer(int id, Buffer buffer, int maxItems, int sleepTime) {
        this.id = id;
        this.buffer = buffer;
        this.maxItems = maxItems;
        this.sleepTime = sleepTime;
    }

    public void run() { // <EDITADO>
        for (int i = 0; i < maxItems; i++) {
            try {
                Thread.sleep(sleepTime);
                int item = (int) (Math.random() * 100);
                System.out.println("Producer " + id + " produced item " + item);
                buffer.put(item);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

class Consumer implements Runnable { // <EDITADO>
    private final Buffer buffer;
    private final int sleepTime;
    private final int id;
    private final boolean consumeEven; // <ADICIONADO>

    public Consumer(int id, Buffer buffer, int sleepTime, boolean consumeEven) { // <EDITADO>
        this.id = id;
        this.buffer = buffer;
        this.sleepTime = sleepTime;
        this.consumeEven = consumeEven; // <ADICIONADO>
    }

    public void run() { // <EDITADO>
        while (true) {
            int item = buffer.remove(consumeEven);
            if (item == -1) continue; // <ADICIONADO>
            System.out.println("Consumer " + id + " consumed item " + item);
            try {
                Thread.sleep(sleepTime);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

import java.util.LinkedList; // <EDITADO>
import java.util.Queue; // <EDITADO>

class Buffer {
    private final Queue<Integer> data = new LinkedList<>(); // <EDITADO>
    private final int MAX_SIZE = 100; // <ADICIONADO>

    public synchronized void put(int value) { // <EDITADO>
        while (data.size() >= MAX_SIZE) { // <ADICIONADO>
            try {
                wait(); // <ADICIONADO>
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        data.add(value);
        System.out.println("Inserted: " + value + " | Buffer size: " + data.size());
        notifyAll(); // <ADICIONADO>
    }

    public synchronized int remove(boolean consumeEven) { // <EDITADO>
        while (data.isEmpty()) {
            try {
                wait(); // <ADICIONADO>
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        int attempts = 0;
        while (attempts++ < data.size()) {
            int item = data.remove();
            boolean isEven = item % 2 == 0;
            if ((consumeEven && isEven) || (!consumeEven && !isEven)) {
                System.out.println("Removed: " + item + " | Buffer size: " + data.size());
                notifyAll(); // <ADICIONADO>
                return item;
            } else {
                data.add(item); // <ADICIONADO>
            }
        }

        // Não encontrou item que satisfaz — tenta novamente depois
        return -1; // <ADICIONADO>
    }
}






